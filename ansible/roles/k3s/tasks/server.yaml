---
# k3s Server Installation
# Installs and configures k3s server (control plane) node
# Only runs on hosts in the 'server' group

- name: Determine deployment context
  ansible.builtin.set_fact:
    is_local_deployment: '{{ inventory_hostname == ansible_hostname or ansible_connection | default("ssh") == "local" }}'

- name: Create directory for K3s data
  ansible.builtin.file:
    path: '{{ base_dir }}'
    state: directory
    mode: '0755'

- name: Install k3s server
  ansible.builtin.command:
    cmd: '{{ k3s_install_script_path }}'
    creates: /usr/local/bin/k3s-uninstall.sh
  environment:
    INSTALL_K3S_SKIP_DOWNLOAD: "{{ 'true' if air_gapped | default(false) | bool else omit }}"
    INSTALL_K3S_EXEC: >-
      --default-local-storage-path={{ base_dir }}
      --write-kubeconfig-mode=0640
      {% if use_staging_node | default(false) %}--disable-default-registry-endpoint{% endif %}
      {{ k3s_extra_args }}
    INSTALL_K3S_VERSION: '{{ k3s_version | default("") }}'
    K3S_TOKEN: '{{ k3s_token }}'
    UNINSTALL_K3S_SH: /usr/local/bin/k3s-uninstall.sh
    KUBECONFIG: '{{ kubeconfig_yaml }}'
  register: k3s_install_result

- name: Restart k3s to pick up registry config changes
  ansible.builtin.systemd:
    name: k3s
    state: restarted
  when:
    - registry_config_changed | default(false)
    - not k3s_install_result.changed

- name: Update kubeconfig group permissions since write-kubeconfig-group isn't working
  ansible.builtin.file:
    path: '{{ kubeconfig_yaml }}'
    state: file
    mode: '0640'
    group: '{{ kubeconfig_group }}'

- name: Setup kubeconfig for remote deployment
  when: not is_local_deployment
  block:
    - name: Set kubeconfig dir path
      ansible.builtin.set_fact:
        local_kubeconfig_yaml_dir: '{{ scout_repo_dir }}/.kube/scout/{{ ansible_host | default(inventory_hostname) }}'

    - name: Set kubeconfig path
      ansible.builtin.set_fact:
        local_kubeconfig_yaml: '{{ local_kubeconfig_yaml_dir }}/config'

    - name: Fetch k3s kubeconfig
      ansible.builtin.slurp:
        src: '{{ kubeconfig_yaml }}'
      register: k3s_kubeconfig_raw

    - name: Parse and modify kubeconfig
      ansible.builtin.set_fact:
        k3s_kubeconfig: '{{ k3s_kubeconfig_raw.content | b64decode | from_yaml }}'

    - name: Update server address in kubeconfig
      ansible.builtin.set_fact:
        modified_kubeconfig: '{{ k3s_kubeconfig | combine(cluster_update, recursive=True) }}'
      vars:
        cluster_update:
          clusters:
            - name: '{{ k3s_kubeconfig.clusters[0].name }}'
              cluster:
                server: 'https://{{ ansible_host | default(inventory_hostname) }}:6443'
                # certificate-authority-data: '{{ k3s_kubeconfig.clusters[0].cluster["certificate-authority-data"] }}'
                # NOTE: The certificates we have only validate for hostnames that we can't use to reach the machines, so we cannot TLS validate the connection
                insecure-skip-tls-verify: true

    - name: Create kubeconfig dir
      ansible.builtin.file:
        path: '{{ local_kubeconfig_yaml_dir }}'
        state: directory
        mode: '0700'
      delegate_to: localhost

    - name: Write modified kubeconfig locally
      ansible.builtin.copy:
        content: '{{ modified_kubeconfig | to_nice_yaml }}'
        dest: '{{ local_kubeconfig_yaml }}'
        mode: '0600'
      delegate_to: localhost

- name: Ensure k3s control plane server is started
  ansible.builtin.systemd:
    name: k3s
    state: started
    enabled: true
    scope: system
  register: k3s_systemd_start_k3s
  until: k3s_systemd_start_k3s is succeeded
  retries: 3
  delay: 3
  failed_when:
    - k3s_systemd_start_k3s is not succeeded
    - not ansible_check_mode
  changed_when: false

- name: Check that the server is available to accept connections
  ansible.builtin.wait_for:
    port: 6443
    host: 127.0.0.1
    delay: 5
    sleep: 5
    timeout: 300
  changed_when: false

- name: Check that server is ready
  ansible.builtin.command:
    cmd: kubectl get nodes
  environment:
    KUBECONFIG: '{{ kubeconfig_yaml }}'
  changed_when: false
  failed_when: >-
    kubectl_get_nodes_result.stdout.find("was refused") != -1 or
    kubectl_get_nodes_result.stdout.find("ServiceUnavailable") != -1
  register: kubectl_get_nodes_result
  until:
    - kubectl_get_nodes_result.rc == 0
    - kubectl_get_nodes_result.stdout.find("NotReady") == -1
  retries: 30
  delay: 5

- name: Apply taint to control plane node
  kubernetes.core.k8s_taint:
    name: '{{ inventory_hostname }}'
    state: present
    taints:
      - key: node-role.kubernetes.io/control-plane
        effect: PreferNoSchedule
  environment:
    KUBECONFIG: '{{ kubeconfig_yaml }}'
  # Skip taint on staging nodes (single-node cluster needs to run workloads)
  when: "'staging' not in group_names"
