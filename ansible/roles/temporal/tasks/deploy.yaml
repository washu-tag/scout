---
# Kubernetes deployment tasks for Temporal cluster
# These tasks run on the server host (which has access to k3s_cluster inventory variables)
# NOTE: This role expects Cassandra and Elasticsearch to already be deployed

- name: Create namespace
  kubernetes.core.k8s:
    name: '{{ temporal_namespace }}'
    api_version: v1
    kind: Namespace
    state: present

# Copy Cassandra superuser secret to temporal namespace
- name: Get Cassandra superuser secret
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    name: '{{ cassandra_cluster_name | default("cassandra-cluster") }}-superuser'
    namespace: '{{ cassandra_namespace }}'
  register: cassandra_secret

- name: Create Cassandra superuser secret in temporal namespace
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: '{{ cassandra_cluster_name | default("cassandra-cluster") }}-superuser'
        namespace: '{{ temporal_namespace }}'
      type: Opaque
      data: '{{ cassandra_secret.resources[0].data }}'

# Get Elasticsearch password for visibility store
- name: Get Elasticsearch password
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    name: '{{ elasticsearch_cluster_name | default("elasticsearch") }}-es-elastic-user'
    namespace: '{{ elasticsearch_namespace }}'
  register: elasticsearch_password_secret
  no_log: true

- name: Decode Elasticsearch password
  set_fact:
    elasticsearch_password: '{{ elasticsearch_password_secret.resources[0].data.elastic | b64decode }}'
  no_log: true

# Build Temporal server config with optional authorization
- name: Build Temporal server config
  set_fact:
    temporal_server_config:
      namespaces:
        create: true
      persistence:
        default:
          driver: 'cassandra'
          cassandra:
            hosts:
              [
                '{{ cassandra_cluster_name | default("cassandra-cluster") }}-{{ cassandra_datacenter_name | default("dc1") }}-service.{{ cassandra_namespace }}',
              ]
            port: 9042
            keyspace: temporal
            existingSecret: '{{ cassandra_cluster_name | default("cassandra-cluster") }}-superuser'
            replicationFactor: 1
            consistency:
              default:
                consistency: 'local_quorum'
                serialConsistency: 'local_serial'

- name: Add authorization config if OIDC enabled
  when: temporal_oidc_enabled
  set_fact:
    temporal_server_config: '{{ temporal_server_config | combine(temporal_auth_config, recursive=true) }}'
  vars:
    temporal_auth_config:
      authorization:
        jwtKeyProvider:
          keySourceURIs:
            - '{{ keycloak_oidc_certs_url }}'
          refreshInterval: 1m
        permissionsClaimName: groups
        authorizer: default
        claimMapper: default

# Build Temporal web config
- name: Build base Temporal web config
  set_fact:
    temporal_web_config:
      ingress:
        enabled: true
        ingressClassName: traefik
        hosts:
          - 'temporal.{{ server_hostname }}'

- name: Add web OIDC config if enabled
  when: temporal_oidc_enabled
  set_fact:
    temporal_web_config: '{{ temporal_web_config | combine(temporal_web_oidc_config, recursive=true) }}'
  vars:
    temporal_web_oidc_config:
      additionalEnv:
        - name: TEMPORAL_AUTH_ENABLED
          value: 'true'
        - name: TEMPORAL_AUTH_PROVIDER_URL
          value: '{{ keycloak_realm_url }}'
        - name: TEMPORAL_AUTH_CLIENT_ID
          value: '{{ keycloak_temporal_client_id }}'
        - name: TEMPORAL_AUTH_CLIENT_SECRET
          value: '{{ keycloak_temporal_client_secret }}'
        - name: TEMPORAL_AUTH_CALLBACK_URL
          value: 'https://temporal.{{ server_hostname }}/auth/sso/callback'
        - name: TEMPORAL_AUTH_SCOPES
          value: openid microprofile-jwt
      ingress:
        annotations:
          traefik.ingress.kubernetes.io/router.middlewares: >
            kube-system-oauth2-proxy-error@kubernetescrd,
            kube-system-oauth2-proxy-auth@kubernetescrd

# Deploy Temporal
- name: Deploy Temporal
  ansible.builtin.include_role:
    name: scout_common
    tasks_from: deploy_helm_chart
  vars:
    helm_chart_name: temporal
    helm_chart_ref: temporal/temporal
    helm_chart_version: '{{ temporal_version }}'
    helm_chart_namespace: '{{ temporal_namespace }}'
    helm_repo_name: temporal
    helm_repo_url: https://raw.githubusercontent.com/temporalio/helm-charts/refs/heads/gh-pages/
    helm_chart_timeout: 15m
    helm_chart_values:
      prometheus:
        enabled: false
      grafana:
        enabled: false
      cassandra:
        enabled: false
      elasticsearch:
        enabled: false
        external: true
        version: 'v7' # All ES versions (7/8/9) use v7 template format
        scheme: 'http' # TLS disabled on Elasticsearch for simplicity
        host: '{{ elasticsearch_cluster_name | default("elasticsearch") }}-es-http.{{ elasticsearch_namespace }}'
        port: 9200
        username: 'elastic'
        password: '{{ elasticsearch_password }}'
        visibilityIndex: 'temporal_visibility_v1'
        logLevel: 'error'
      server:
        replicaCount: '{{ temporal_server_replica_count | default(1) }}'
        config: '{{ temporal_server_config }}'
        internalFrontend:
          enabled: true
        env:
          - name: ELASTICSEARCH_PASSWORD
            valueFrom:
              secretKeyRef:
                name: '{{ elasticsearch_cluster_name | default("elasticsearch") }}-es-elastic-user'
                key: elastic
      web: '{{ temporal_web_config }}'

- name: Wait for Temporal schema job to complete
  shell: >-
    JOB_NAME=$(kubectl -n {{ temporal_namespace }} get jobs -l app.kubernetes.io/component=schema
    --sort-by='.metadata.creationTimestamp'
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "");
    if [ -n "$JOB_NAME" ]; then
      kubectl -n {{ temporal_namespace }} wait --for=condition=complete --timeout=300s job/$JOB_NAME;
    fi
  register: temporal_schema
  changed_when: false

# Set up scheduled tasks
- name: Construct cron schedule
  when: scheduled_ingest_cron is undefined and scheduled_ingest_hour is defined
  set_fact:
    scheduled_ingest_cron: '0 {{ scheduled_ingest_hour }} * * *'

- name: Add scheduled task for prospective report indexing
  when: scheduled_ingest_cron is defined
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: batch/v1
      kind: Job
      metadata:
        name: 'add-prospective-indexing'
        namespace: '{{ temporal_namespace }}'
        labels:
          app: prospective-indexing
      spec:
        backoffLimit: 5
        template:
          metadata:
            labels:
              app: prospective-indexing
          spec:
            restartPolicy: Never
            containers:
              - name: prospective-indexing-setup
                image: temporalio/admin-tools
                env:
                  - name: TEMPORAL_ADDRESS
                    value: 'temporal-internal-frontend.{{ temporal_namespace }}:7236'
                command:
                  - temporal
                  - schedule
                  - create
                  - '--schedule-id'
                  - ScheduledReportIngest
                  - '--workflow-id'
                  - ScheduledReportIngest
                  - '--task-queue'
                  - ingest-hl7-log
                  - '--type'
                  - IngestHl7LogWorkflow
                  - '--cron'
                  - '{{ scheduled_ingest_cron }}'
