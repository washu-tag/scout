- name: Add Superset Helm repository
  kubernetes.core.helm_repository:
    name: superset
    repo_url: https://apache.github.io/superset

- name: Create namespace
  kubernetes.core.k8s:
    name: superset
    api_version: v1
    kind: Namespace
    state: present

- name: Create ConfigMap for datasource and dashboard yaml
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: dashboard-config
        namespace: superset
      data:
        metadata.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/metadata.yaml') }}
        Scout_Data_Lake.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/databases/Scout_Data_Lake.yaml') }}
        reports.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/datasets/Scout_Data_Lake/reports.yaml') }}
        Modality_2.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Modality_2.yaml') }}
        Count_1.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Count_1.yaml') }}
        Facility_by_date_8.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Facility_by_date_8.yaml') }}
        Race_4.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Race_4.yaml') }}
        Report_5.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Report_5.yaml') }}
        Service_Name_6.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Service_Name_6.yaml') }}
        Study_Instance_UID_7.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Study_Instance_UID_7.yaml') }}
        Sex_3.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/charts/Sex_3.yaml') }}
        Scout_1.yaml: |
          {{ lookup('file', '{{ scout_repo_dir }}/analytics/dashboards/Scout_1.yaml') }}

- name: Install/Upgrade Superset Helm chart
  kubernetes.core.helm:
    name: superset
    chart_ref: superset/superset
    chart_version: 0.14.2
    release_namespace: superset
    create_namespace: true
    release_state: present
    update_repo_cache: true
    wait: true
    wait_timeout: 15m
    atomic: true
    values:
      image:
        repository: '{{ superset_image | default("ghcr.io/washu-tag/superset") }}'
        tag: 4.1.2
      extraSecretEnv:
        SUPERSET_SECRET_KEY: '{{ superset_secret }}'
      ingress:
        enabled: true
        ingressClassName: traefik
        annotations:
          traefik.ingress.kubernetes.io/router.middlewares: >
            kube-system-oauth2-proxy-error@kubernetescrd,
            kube-system-oauth2-proxy-auth@kubernetescrd
        path: /
        hosts:
          - '{{ server_hostname }}'
      postgresql:
        enabled: false
      supersetNode:
        connections:
          db_host: 'postgresql-cluster-rw.{{ postgres_cluster_namespace }}'
          db_port: '5432'
          db_user: '{{ superset_postgres_user }}'
          db_pass: '{{ superset_postgres_password }}'
          db_name: superset
      configOverrides:
        branding: |
          APP_NAME = "Scout Analytics"
          APP_ICON = "https://{{ server_hostname }}/launchpad/scout.png"
          APP_ICON_WIDTH = 200
          LOGO_TARGET_PATH = "https://{{ server_hostname }}/launchpad"
          LOGO_TOOLTIP = "Scout Launchpad"
          FAVICONS = [{"href": "https://{{ server_hostname }}/launchpad/scout.png"}]
        custom_routing: |
          from flask import redirect, url_for
          from flask_appbuilder import expose, IndexView

          from superset.superset_typing import FlaskResponse

          class SupersetIndexView(IndexView):
              @expose("/")
              def index(self) -> FlaskResponse:
                  return redirect(url_for("Superset.dashboard", dashboard_id_or_slug="scout"))

          FAB_INDEX_VIEW = f"{SupersetIndexView.__module__}.{SupersetIndexView.__name__}"
        enable_oauth: |
          # https://superset.apache.org/docs/configuration/configuring-superset/#keycloak-specific-configuration-using-flask-oidc
          # https://github.com/apache/superset/discussions/29770
          from flask_appbuilder.security.manager import AUTH_OID, AUTH_REMOTE_USER, AUTH_DB, AUTH_LDAP, AUTH_OAUTH
          from superset.security import SupersetSecurityManager
          from flask_oidc import OpenIDConnect
          from flask_appbuilder.security.views import AuthOIDView
          from flask_login import login_user
          from flask_jwt_extended import verify_jwt_in_request
          from urllib.parse import quote
          from flask_appbuilder.views import ModelView, SimpleFormView, expose
          from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union
          from flask import (
              redirect,
              request,
              session
          )
          import logging
          import sys
          import os
          import json

          class OIDCSecurityManager(SupersetSecurityManager):

              def __init__(self, appbuilder):
                  super(OIDCSecurityManager, self).__init__(appbuilder)
                  if self.auth_type == AUTH_OID:
                      self.oid = OpenIDConnect(self.appbuilder.get_app)
                  self.authoidview = AuthOIDCView

              # custom function for OIDC roles_mapping. Just a copy/past from _oauth_calculate_user_roles
              def is_item_public(self, permission_name, view_name):
                  verify_jwt_in_request(optional=True) # Attempt to parse any existing JWT and fail silently
                  return super().is_item_public(permission_name, view_name)
              def _oid_calculate_user_roles(self, userinfo) -> List[str]:
                  user_role_objects = set()
                  # apply AUTH_ROLES_MAPPING
                  if len(self.auth_roles_mapping) > 0:
                      user_role_keys = userinfo.get("groups", [])
                      user_role_objects.update(self.get_roles_from_keys(user_role_keys))

                  # apply AUTH_USER_REGISTRATION_ROLE
                  if self.auth_user_registration:
                      registration_role_name = self.auth_user_registration_role

                      # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,
                      # use it for the registration role
                      if self.auth_user_registration_role_jmespath:
                          import jmespath

                          registration_role_name = jmespath.search(
                              self.auth_user_registration_role_jmespath, userinfo
                          )

                      # lookup registration role in flask db
                      fab_role = self.find_role(registration_role_name)
                      logging.info("fab_role %s",fab_role )
                      if fab_role:
                          user_role_objects.add(fab_role)
                      else:
                          logging.warning(
                              "Can't find AUTH_USER_REGISTRATION role: %s", registration_role_name
                          )
                  return list(user_role_objects)


          class AuthOIDCView(AuthOIDView):
              @expose('/login/', methods=['GET', 'POST'])
              def login(self, flag=True):
                  sm = self.appbuilder.sm
                  oidc = sm.oid
                  @self.appbuilder.sm.oid.require_login
                  def handle_login():
                      user = sm.auth_user_oid(oidc.user_getfield('email'))
                      # We already have this user in flask DB. If sync_at_login is True we`ll calculate new roles for gim
                      if user:
                          info = oidc.user_getinfo(['preferred_username', 'given_name', 'family_name', 'email', 'groups', 'role_keys'])
                          logging.info("User info: %s", info)
                          logging.info("User groups: %s", oidc.user_getfield('groups', []))
                          logging.info("User role_keys: %s", oidc.user_getfield('role_keys', []))
                          userRoles = sm._oid_calculate_user_roles(info)
                          logging.info("Calculated new roles for user='%s' as: %s", info.get('preferred_username'), userRoles)
                          logging.info("USER='%s'", user)
                          user.roles = userRoles
                          sm.update_user(user)

                          # info2 = sm.get_oauth_user_info('keycloak', None)
                          # logging.info("User info from OIDC: %s", info2)
                      # # this user is new for flask DB. We will calculate his roles and add him to DB. Than login as usual
                      if user is None:
                          info = oidc.user_getinfo(['preferred_username', 'given_name', 'family_name', 'email', 'groups'])
                          logging.info("User info: %s", info)
                          logging.info("User groups: %s", oidc.user_getfield('groups', []))
                          logging.info("User role_keys: %s", oidc.user_getfield('role_keys', []))
                          userRoles = sm._oid_calculate_user_roles(info)
                          logging.info("Calculated  roles for new user='%s' as: %s", info.get('preferred_username'), userRoles)
                          # ZR
                          user = sm.add_user(info.get('preferred_username',''), info.get('given_name',''), info.get('family_name',''),
                                          info.get('email',''), userRoles)
                      login_user(user, remember=False)
                      return redirect(self.appbuilder.get_url_for_index)      
                  return handle_login()

              @expose('/logout/', methods=['GET', 'POST'])
              # @oidc.require_login
              def logout(self):
                  oidc = self.appbuilder.sm.oid
                  oidc.logout()
                  super(AuthOIDCView, self).logout()
                  redirect_url = request.url_root.strip('/')
                  client_id = oidc.client_secrets.get('client_id')
                  session.clear()
                  return redirect('https://{{ server_hostname }}/oauth2/sign_out')

          # Write the client secrets to a file
          client_secrets_json = {
            "keycloak": {
              "issuer": "https://{{ server_hostname }}/kc/realms/scout",
              "api_base_url": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect",
              "auth_uri": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect/auth",
              "client_id": "{{ keycloak_superset_client_id }}",
              "client_secret": "{{ keycloak_superset_client_secret }}",
              "redirect_uris": [
                "https://{{ server_hostname }}/*"
              ],
              "client_kwargs": {
                "scope": "openid microprofile-jwt",
              },
              "userinfo_uri": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect/userinfo",
              "token_uri": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect/token",
              "token_introspection_uri": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect/token/introspect",
              "jwks_uri": "https://{{ server_hostname }}/kc/realms/scout/protocol/openid-connect/certs",
              "request_token_url": None,
            }
          }

          client_secrets_path = '/app/client_secret.json'
          os.makedirs(os.path.dirname(client_secrets_path), exist_ok=True)
          with open(client_secrets_path, 'w') as f:
              json.dump(client_secrets_json, f)

          AUTH_TYPE = AUTH_OID
          SECRET_KEY = 'SomethingNotEntirelySecret'
          OIDC_CLIENT_SECRETS =  '/app/client_secret.json'
          OIDC_ID_TOKEN_COOKIE_SECURE = False
          OIDC_INTROSPECTION_AUTH_METHOD = 'client_secret_post'
          CUSTOM_SECURITY_MANAGER = OIDCSecurityManager

          # Will allow user self registration, allowing to create Flask users from Authorized User
          AUTH_USER_REGISTRATION = True

          # The default user self registration role
          AUTH_USER_REGISTRATION_ROLE = 'Alpha'

          AUTH_ROLES_SYNC_AT_LOGIN = True

          AUTH_ROLES_MAPPING = {
              "superset_admin": ["Admin"],
              "superset_alpha": ["Alpha"],
              "superset_gamma": ["Gamma"],
          }
      extraVolumes:
        - name: dashboard-config
          configMap:
            name: dashboard-config
            items:
              - key: metadata.yaml
                path: analytics/metadata.yaml
              - key: Scout_Data_Lake.yaml
                path: analytics/databases/Scout_Data_Lake.yaml
              - key: reports.yaml
                path: analytics/datasets/Scout_Data_Lake/reports.yaml
              - key: Modality_2.yaml
                path: analytics/charts/Modality_2.yaml
              - key: Count_1.yaml
                path: analytics/charts/Count_1.yaml
              - key: Facility_by_date_8.yaml
                path: analytics/charts/Facility_by_date_8.yaml
              - key: Race_4.yaml
                path: analytics/charts/Race_4.yaml
              - key: Report_5.yaml
                path: analytics/charts/Report_5.yaml
              - key: Service_Name_6.yaml
                path: analytics/charts/Service_Name_6.yaml
              - key: Study_Instance_UID_7.yaml
                path: analytics/charts/Study_Instance_UID_7.yaml
              - key: Sex_3.yaml
                path: analytics/charts/Sex_3.yaml
              - key: Scout_1.yaml
                path: analytics/dashboards/Scout_1.yaml

      extraVolumeMounts:
        - name: dashboard-config
          mountPath: /app/dashboard-config

      init:
        initscript: |-
          {% raw %}
          #!/bin/sh
          set -eu
          echo "Upgrading DB schema..."
          superset db upgrade
          echo "Initializing roles..."
          superset init
          {{ if .Values.init.createAdmin }}
          echo "Creating admin user..."
          superset fab create-admin \
                          --username {{ .Values.init.adminUser.username }} \
                          --firstname {{ .Values.init.adminUser.firstname }} \
                          --lastname {{ .Values.init.adminUser.lastname }} \
                          --email {{ .Values.init.adminUser.email }} \
                          --password {{ .Values.init.adminUser.password }} \
                          || true
          {{- end }}
          {{ if .Values.init.loadExamples }}
          echo "Loading examples..."
          superset load_examples
          {{- end }}
          if [ -f "{{ .Values.extraConfigMountPath }}/import_datasources.yaml" ]; then
            echo "Importing database connections.... "
            superset import_datasources -p {{ .Values.extraConfigMountPath }}/import_datasources.yaml
          fi
          # Import the dashboard
          if [ -d /app/dashboard-config ]; then
            echo "Importing dashboard..."
            cd /app/dashboard-config
            zip -r ~/dashboard.zip .
            cd -
            superset import-dashboards -p ~/dashboard.zip -u admin
            result=$?
            if [ $result != 0 ]; then
              echo "Error importing dashboard"
              exit $result
            fi
            rm -f ~/dashboard.zip
            echo "Dashboard imported successfully"
          fi
          {% endraw %}
